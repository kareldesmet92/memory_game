# memory_game
There are 3 different game settings in this memory game. When you start the game, you will see a menu, where you can choose for one of the following options:
1)	‘Alone’. Time is your opponent in this game. You will have to try to find each pair of matching figures in the shortest possible time. The larger the amount of time remaining, the more points you will get at the end of the game. Be careful, when you choose for a higher difficulty level, not only the amount of tiles will increase, but there will also be some tiles with a penalty cards and/or bonus cards. A bonus cards will give you some extra time. A penalty card will do nothing when clicking the first time, but once you click the same penalty card again, you will get a huge time penalty. In order to reach higher top scores, you will certainly have to remember the location of these penalty cards. You will receive a higher starting time when playing a more difficult level, so that you are able to reach higher scores in more difficult levels. If your score is high enough, it will be listed in the top 10 high scores.
2)	‘Computer’. In this game you play against a robot. Increasing the difficulty level will increase the amount of pairs to be matched, but will also increase the robot’s performance. He will have a larger ‘memory’. Again here, when clicking a penalty card, you will lose points. Penalty cards will always turned on the back again, so it’s important to remember their location in order not to click them again. Clicking a bonus card will give you an extra turn, just like matching a pair. In theory you are able to reach higher scores when playing the most difficult levels, but the robot will make it very hard to you. For this game, you can also consult the high scores. 
3)	‘Human’. You play memory matching game with another human. Again, when increasing the difficulty level, not only the amount of pairs to be matched will increase, but also the amount of penalty/bonus cards. When clicking a penalty card, you will lose some points. Clicking a bonus card will give you 1 extra turn to find a matching pair. The moment you have found a matching pair, you will be earned with an extra turn. 

# To start the game:
•	First select the difficulty level. As explained above, the difficulty level as directly correlated with the size of the playing field and amount of penalty and/or bonus cards. 
•	Select one of the game types above. 
•	Fill in the player(s) name
•	Select the theme: Fruit, Presidents or Landmarks
•	Press ‘Play’ to start the game, ‘Exit’ to leave the game and ‘High Scores’ to get access to the high scores of the Alone and Computer game. 

# Classes: 
Card: Is an abstract class that represents a card or tile. It serves as an abstraction for the three types of cards possible: ‘NormalCard’, ‘BonusCard’ and ‘PenaltyCard’. It extends the JButton class. Each instance contains 2 images: one for the back and one picture for the front (to picture to be matched). Further it contains an id and a boolean indicator to indicate if the card is turned or not (back -> false).
NormalCard: extends the Card class and represents the cards for which you need to find the matching pair. In addition it contains a ‘pairId’, indicating with which other Card this one forms a pair. 
BonusCard: Extends the Card class and sets the right image for a bonus card. 
PenaltyCard: Extends the Card class and sets the right image for a penalty card. 
CardPair: represents a matching pair of NormalCards. In the constructor it sets for both cards the right id and pairId so that they ‘point’ to each other. 
CardDeck: In the constructor of this class you give the theme and the amount of pairs, bonus cards and penalty cards, and it makes a card deck in the form of an ArrayList. Furthermore, there is a function to shuffle this card deck so that eventually the cards are placed at random on the grid. There is also a list to keep the NormalCards apart. 
GameMode: contains logic components that are needed for the game, without containing graphical user interface code or references. It contains a CardDeck, 2 Players, the theme (String) and difficulty level (int). In order to load and setup all the components of the game, this constructor needs to be called and it makes a card deck according to the right difficulty level, sets the players, etc.
Player: simple class to represent a player, containing a name (String) and score (int). 
HighScores: this class takes care of reading and writing the player’s score. When writing a score, either for the ‘Alone’ game or ‘Computer’ game the corresponding method in this class read the file in the ‘highscores’ folder and writes this score on the right place. The methods in this class are static because they do not work on a particular instance. 
Game: in this class the main method calls the Game() constructor to start the game. The whole game is initiated here. The constructor makes the game menu where one can choose the difficulty level, game settings, theme, etc. This class implements the ActionListener and ChangeListener class to detect the corresponding events on the slider, TextField, etc. With the ActionListener, the game settings are stored in the class’ instance variables. Clicking on the ‘Play’ button at the bottom, the actionlistener will call the right GameManager constructor, corresponding to which type of game one has chosen. Calling one of the GameManager constructors will make appear the playing field start the actual game of finding matching pairs. 
GameManager: abstract class for the three types of games: alone, computer or human. It creates a JFrame and contains the GameMode. 
GameManagerAlone: contains the logic for the Alone game and makes the necessary adaptations in the GUI. It generates the playing field as a grid (GridLayout) of Cards. To each Card, an ActionListener is added. Depending on clicking a NormalCard, BonusCard or PenaltyCard to necessary methods are called. The method ‘AddToCardBuffer’ is very important because it contains the cards which you have turned in 1 turn. When you have turned two cards that do not form a pair, it starts the ‘cardTimer’ Timer so that these cards are again turned on their back in 0,5s. When you have found a matching pair, there is no need to start this timer. The CardBuffer is anyhow always cleared after turning 2 NormalCards. The ‘checkEndGame’ method is called to check if the number of pairs found is equal to the number of pairs that need to be found. When this is the case, it calls the ‘stop’ method to take off all ActionListeners from the cards so that no actions can be performed after the game has ended. This class contains also an overall timer serving as stopwatch. 
GameManagerHuman: similar class containing the functionality for the game you can play against a human opponent. It contains similar, but slightly adapted methods as the previous one, but it does not contain an over Timer for the stopwatch. An important method is the ‘switchTurn’ method, which takes care of switching the label colors and switching the turn to the other person. 
GameManagerComputer: This is similar to the previous class, but a ‘robot’ is implemented as well here, spread over multiple methods. The human player always starts the game. When his turn has ended, the ‘switchTurn’ method starts the computerTimer. Here the computer start his turn, first checking if a matching pair his stored in his memory (checkPairsInMemory). If not the case, it takes a random card of the ‘notTurnedCardList’ and checks the matching pair is stored in his memory (checkInMemory). If this is the case, then computerTimer2 is started to turn this matching pair. If there was no matching pair found in the memory, computerTimer is started to turn again a random card. The cards are at the end again compared in the CardBuffer and turned back if necessary. The ‘memory’ of the computer is an ArrayList with at most the length equal to the difficulty level. The most recent cards, either by the human or computer, are stored in this arraylist. The oldest cards, or matching cards are removed. 

# Relationships between classes: 
•	NormalCard, PenaltyCard and BonusCard are subclasses from the abstract Card class. So they acquire the properties (like id, imgBack, …) if this class. 
•	CardPair calls the constructor of NormalCard in order to create its instance variables. 
•	CardDeck calls the constructors of CardPair, PenaltyCard and BonusCard. 
•	GameMode calls the constructor of CardDeck in the ‘makeCardDeck’ method. It contains 2 instances of the Player class. 
•	Game calls the constructor of GameMode and the different GameManager classes. 
•	GameManagerAlone extends the GameManager class. It calls the static method writeAloneScore(int) of HighScores class. 
•	GameManagerHuman extends the GameManager class. 
•	GameManagerComputer extends the GameManager class. It calls the static method writeComputerScore(int) of the HighScores class. 

# Multiple Themes: 
To allow multiple themes, I have included a JComboBox in the game menu frame. It’s a kind of drop down list from where you can choose the theme. By use of an actionlistener the theme is stored in a local instance variable when the user selects it. The theme is then passed as an argument to the GameMode constructor, which on his turn calls the CardDeck constructor in the ‘makeCardDeck’ method. And so the theme is passed from constructor to constructor until it arrives at the NormalCard. There the method ‘setImg’ has as argument a String for the location of the figures. This location String is exactly the same as the theme String and the name of the folder where the figures are stored. This way, the program knows exactly where to look for the figures of the corresponding theme.  




